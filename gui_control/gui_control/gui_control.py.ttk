import sys
import time
import json
import threading
from dataclasses import dataclass
from typing import List, Dict
import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Header
from sensor_msgs.msg import JointState
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import tkinter.font as tkfont

from .utils.mapping import *
from .config.constants import _HAND_CONFIGS
LOOP_TIME = 1000 # Loop action interval time (ms)
class ROS2NodeManager:
    """ROS2 node manager, handles ROS communication"""
    
    def __init__(self, node_name: str = "hand_control_node"):
        self.node = None
        self.publisher = None
        self.joint_state = JointState()
        self.joint_state.header = Header()
        self.status_callbacks = []
        
        # Initialize ROS2 node
        self.init_node(node_name)

    def add_status_callback(self, callback):
        """Add status callback"""
        self.status_callbacks.append(callback)

    def emit_status(self, status_type: str, message: str):
        """Emit status signal"""
        for callback in self.status_callbacks:
            callback(status_type, message)

    def init_node(self, node_name: str):
        """Initialize ROS2 node"""
        try:
            if not rclpy.ok():
                rclpy.init(args=None)
            self.node = Node(node_name)
            
            # Declare parameters
            self.node.declare_parameter('hand_type', 'left')
            self.node.declare_parameter('hand_joint', 'L10')
            self.node.declare_parameter('topic_hz', 30)
            self.node.declare_parameter('is_arc', False)
            
            # Get parameters
            self.hand_type = self.node.get_parameter('hand_type').value
            self.hand_joint = self.node.get_parameter('hand_joint').value
            self.hz = self.node.get_parameter('topic_hz').value
            self.is_arc = self.node.get_parameter('is_arc').value
            
            if self.is_arc == True:
                # Create publisher
                self.publisher_arc = self.node.create_publisher(
                    JointState, f'/cb_{self.hand_type}_hand_control_cmd_arc', 10
                )
            # Create publisher
            self.publisher = self.node.create_publisher(
                JointState, f'/cb_{self.hand_type}_hand_control_cmd', 10
            )
            # New speed / torque publishers
            self.speed_pub = self.node.create_publisher(
                String, f'/cb_hand_setting_cmd', 10)
            self.torque_pub = self.node.create_publisher(
                String, f'/cb_hand_setting_cmd', 10)
            self.emit_status("info", f"ROS2 node initialized successfully: {self.hand_type} {self.hand_joint}")
            
            # Start ROS2 spin thread
            self.spin_thread = threading.Thread(target=self.spin_node, daemon=True)
            self.spin_thread.start()
        except Exception as e:
            self.emit_status("error", f"ROS2 initialization failed: {str(e)}")
            raise

    def spin_node(self):
        """Run ROS2 node spin loop"""
        while rclpy.ok() and self.node:
            rclpy.spin_once(self.node, timeout_sec=0.1)

    def publish_joint_state(self, positions: List[int]):
        """Publish joint state message"""
        if not self.publisher or not self.node:
            self.emit_status("error", "ROS2 publisher not initialized")
            return
            
        try:
            self.joint_state.header.stamp = self.node.get_clock().now().to_msg()
            self.joint_state.position = [float(pos) for pos in positions]
            hand_config = _HAND_CONFIGS[self.hand_joint]
            if len(hand_config.joint_names) == len(positions):
                if hand_config.joint_names_en != None:
                    self.joint_state.name = hand_config.joint_names_en
                else:
                    self.joint_state.name = hand_config.joint_names
                
            self.publisher.publish(self.joint_state)
            if self.is_arc == True:
                if self.hand_joint == "O6":
                    if self.hand_type == "left":
                        pose = range_to_arc_left(positions,self.hand_joint)
                    elif self.hand_type == "right":
                        pose = range_to_arc_right(positions,self.hand_joint)
                elif self.hand_joint == "L7" or self.hand_joint == "L21" or self.hand_joint == "L25":
                    if self.hand_type == "left":
                        pose = range_to_arc_left(positions,self.hand_joint)
                    elif self.hand_type == "right":
                        pose = range_to_arc_right(positions,self.hand_joint)
                elif self.hand_joint == "L10":
                    if self.hand_type == "left":
                        pose = range_to_arc_left_10(positions)
                    elif self.hand_type == "right":
                        pose = range_to_arc_right_10(positions)
                elif self.hand_joint == "L20":
                    if self.hand_type == "left":
                        pose = range_to_arc_left_l20(positions)
                    elif self.hand_type == "right":
                        pose = range_to_arc_right_l20(positions)
                else:
                    print(f"Current {self.hand_joint} {self.hand_type} does not support radian conversion", flush=True)
                self.joint_state.position = [float(pos) for pos in pose]
                self.publisher_arc.publish(self.joint_state)
            self.emit_status("info", "Joint state published")
        except Exception as e:
            self.emit_status("error", f"Publish failed: {str(e)}")

    def publish_speed(self, val: int):
        joint_len = 0
        if (self.hand_joint.upper() == "O6" or self.hand_joint.upper() == "L6"):
            joint_len = 6
        elif self.hand_joint == "L7":
            joint_len = 7
        elif self.hand_joint == "L10":
            joint_len = 10
        else:
            joint_len = 5
        msg = String()
        v = [val] * joint_len
        data = {
            "setting_cmd": "set_speed",
            "params": {"hand_type":self.hand_type,"speed": v},
        }
        msg.data = json.dumps(data)
        print(f"Speed value: {v}", flush=True)
        self.speed_pub.publish(msg)

    def publish_torque(self, val: int):
        joint_len = 0
        if (self.hand_joint.upper() == "O6" or self.hand_joint.upper() == "L6"):
            joint_len = 6
        elif self.hand_joint == "L7":
            joint_len = 7
        elif self.hand_joint == "L10":
            joint_len = 10
        else:
            joint_len = 5
        msg = String()
        v = [val] * joint_len
        data = {
            "setting_cmd": "set_max_torque_limits",
            "params": {"hand_type":self.hand_type,"torque": v},
        }
        
        msg.data = json.dumps(data)
        print(f"Torque value: {v}", flush=True)
        self.torque_pub.publish(msg)

    def shutdown(self):
        """Shut down ROS2 node"""
        if self.node:
            self.node.destroy_node()
        if rclpy.ok():
            rclpy.shutdown()

class HandControlGUI:
    """Dexterous hand control GUI"""
    
    def __init__(self, ros_manager: ROS2NodeManager):
        self.ros_manager = ros_manager
        self.ros_manager.add_status_callback(self.update_status)
        
        # Get hand configuration
        self.hand_joint = self.ros_manager.hand_joint
        self.hand_type = self.ros_manager.hand_type
        self.hand_config = _HAND_CONFIGS[self.hand_joint]
        
        # Loop control variables
        self.cycle_timer = None
        self.current_action_index = -1
        self.preset_buttons = []
        
        # Initialize UI
        self.init_ui()
        
        # Set timer to publish joint state
        self.publish_timer_id = None
        self.start_publish_timer()

    def init_ui(self):
        """Initialize user interface"""
        # Create main window
        self.root = tk.Tk()
        self.root.title(f'Dexterous Hand Control - {self.hand_type} {self.hand_joint}')
        self.root.geometry('1300x700')
        
        # Styles
        self.style = ttk.Style()
        self.style.configure('TFrame', background='#f0f0f0')
        self.style.configure('TLabel', background='#f0f0f0', font=('Microsoft YaHei', 10))
        self.style.configure('Title.TLabel', font=('Microsoft YaHei', 14, 'bold'), foreground='#165DFF')
        self.style.configure('Group.TLabelframe', borderwidth=2, relief='groove')
        self.style.configure('Group.TLabelframe.Label', font=('Microsoft YaHei', 10, 'bold'), foreground='#165DFF')
        # Info panel style - gray background
        self.style.configure('Info.TFrame', background='#e0e0e0')
        # Highlight style - background while sliding
        self.style.configure('Highlight.TFrame', background='#e6f7ff')  # Light blue background
        
        # Current clicked button index
        self.current_clicked_button = None
        
        # Main frame
        main_frame = ttk.Frame(self.root)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Horizontal paned window
        self.paned_window = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        self.paned_window.pack(fill=tk.BOTH, expand=True)
        
        # Left: joint control panel
        self.joint_control_panel = self.create_joint_control_panel()
        self.paned_window.add(self.joint_control_panel, weight=5)
        
        # Middle: preset actions panel
        self.preset_actions_panel = self.create_preset_actions_panel()
        self.paned_window.add(self.preset_actions_panel, weight=3)
        
        # Right: status monitor panel
        self.status_monitor_panel = self.create_status_monitor_panel()
        self.paned_window.add(self.status_monitor_panel, weight=4)
        
        # Bottom: value display panel
        self.value_display_panel = self.create_value_display_panel()
        self.value_display_panel.pack(fill=tk.X, pady=(10, 0))
        
        # Bind resize event
        self.joint_control_panel.bind('<Configure>', self.on_joint_panel_resize)
        
        # Initial values update
        self.update_value_display()

    def create_joint_control_panel(self):
        """Create joint control panel"""
        frame = ttk.Frame(self.root)
        frame.config(width=600)  # Set minimum width to 400 px
        frame.pack_propagate(False)  # Prevent children from resizing the frame
        # Title
        title_label = ttk.Label(frame, text=f"Joint Control - {self.hand_joint}", style='Title.TLabel')
        title_label.pack(pady=(0, 10))
        
        # Scrollable area
        self.canvas = tk.Canvas(frame, bg='#f0f0f0', highlightthickness=0)
        self.scrollbar = ttk.Scrollbar(frame, orient=tk.VERTICAL, command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas)
        
        self.scrollable_frame.bind(
            "<Configure>",
            self.on_scrollable_frame_configure  # Call method
        )
        
        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        
        # Create sliders
        self.create_joint_sliders(self.scrollable_frame)
        
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        # Initially hide scrollbar
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.scrollbar.pack_forget()  # Hide scrollbar
        
        return frame
    def on_scrollable_frame_configure(self, event):
        """Scrollable area config change event - show/hide scrollbar dynamically"""
        # Update scroll region
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        
        # Check if scrollbar is needed
        scrollable_height = self.scrollable_frame.winfo_reqheight()  # Content height
        canvas_height = self.canvas.winfo_height()  # Canvas height
        
        # Show scrollbar if content taller than canvas; otherwise hide
        if scrollable_height > canvas_height and canvas_height > 0:
            self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        else:
            self.scrollbar.pack_forget()

    def create_joint_sliders(self, parent):
        """Create joint sliders"""
        self.sliders = []
        self.slider_labels = []
        self.slider_frames = []
        
        # Store parent frame reference for later resizing
        self.sliders_parent = parent
        
        for i, (name, value) in enumerate(zip(
            self.hand_config.joint_names, self.hand_config.init_pos
        )):
            # Row frame with margins
            slider_frame = ttk.Frame(parent)
            slider_frame.pack(fill=tk.X, pady=5, padx=(10,0))
            self.slider_frames.append(slider_frame)
            
            # Label
            label = ttk.Label(slider_frame, text=f"{name}: {value}", width=15)
            label.pack(side=tk.LEFT, padx=(0, 10))
            
            # Slider (initial length 300, will resize with window)
            slider = ttk.Scale(slider_frame, from_=0, to=255, value=value, 
                              orient=tk.HORIZONTAL, length=300,
                              command=lambda val, idx=i: self.on_slider_value_changed(idx, val))
            slider.pack(side=tk.LEFT, fill=tk.X, expand=True)
            
            self.sliders.append(slider)
            self.slider_labels.append(label)

    def on_joint_panel_resize(self, event):
        """Joint control panel resize event"""
        panel_width = event.width
        
        # Set new length for all sliders
        for slider in self.sliders:
            # Estimate label/margins width â‰ˆ150
            new_length = max(panel_width - 150, 100)  # Minimum length 100 px
            slider.configure(length=new_length-30)
        # After resize, re-check scrollbar visibility
        self.root.after(100, self.check_scrollbar_visibility)  # Delay to ensure heights updated

    def check_scrollbar_visibility(self):
        """Check scrollbar visibility"""
        if self.canvas.winfo_height() > 0:
            scrollable_height = self.scrollable_frame.winfo_reqheight()
            canvas_height = self.canvas.winfo_height()
            
            if scrollable_height > canvas_height:
                self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            else:
                self.scrollbar.pack_forget()

    def create_preset_actions_panel(self):
        """Create preset actions panel"""
        frame = ttk.Frame(self.root)
        
        # System presets
        sys_preset_group = ttk.LabelFrame(frame, text="System Presets", style='Group.TLabelframe')
        sys_preset_group.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        # Preset buttons (3 columns)
        self.create_system_preset_buttons(sys_preset_group)
        
        # Action buttons frame
        actions_frame = ttk.Frame(frame)
        actions_frame.pack(fill=tk.X, pady=10)
        
        # Cycle button
        self.cycle_button = ttk.Button(actions_frame, text="Cycle Preset Actions", 
                                      command=self.on_cycle_clicked, width=12)
        self.cycle_button.pack(side=tk.LEFT, padx=5)
        
        # Home button
        self.home_button = ttk.Button(actions_frame, text="Return to Home", 
                                     command=self.on_home_clicked, width=12)
        self.home_button.pack(side=tk.LEFT, padx=5)
        
        # Stop button
        self.stop_button = ttk.Button(actions_frame, text="Stop All Actions", 
                                     command=self.on_stop_clicked, width=12)
        self.stop_button.pack(side=tk.LEFT, padx=5)
        
        return frame

    def create_system_preset_buttons(self, parent):
        """Create system preset action buttons - 3 columns"""
        self.preset_buttons = []
        if self.hand_config.preset_actions:
            buttons_frame = ttk.Frame(parent)
            buttons_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            buttons = []
            for idx, (name, positions) in enumerate(self.hand_config.preset_actions.items()):
                # Use tk.Button (not ttk) for better background control
                button = tk.Button(buttons_frame, text=name, bg='#E6F7FF', fg='#1890FF', width=15,
                                relief='raised', bd=1, font=('Microsoft YaHei', 10),
                                command=lambda pos=positions, btn_idx=idx: self.on_preset_action_clicked(pos, btn_idx))
                buttons.append(button)
                self.preset_buttons.append(button)
            
            # 3-column grid
            cols = 3
            for i, button in enumerate(buttons):
                row, col = divmod(i, cols)
                button.grid(row=row, column=col, sticky='ew', padx=5, pady=5)
            
            # Column weights
            for i in range(cols):
                buttons_frame.columnconfigure(i, weight=1)

    def create_status_monitor_panel(self):
        """Create status monitor panel"""
        frame = ttk.Frame(self.root)
        
        # Title
        title_label = ttk.Label(frame, text="Status Monitor", style='Title.TLabel')
        title_label.pack(pady=(0, 10))
        
        # Quick Settings
        quick_set_group = ttk.LabelFrame(frame, text="Quick Settings", style='Group.TLabelframe')
        quick_set_group.pack(fill=tk.X, pady=(0, 10))
        
        # Speed settings
        speed_frame = ttk.Frame(quick_set_group)
        speed_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(speed_frame, text="Speed:").pack(side=tk.LEFT)
        self.speed_var = tk.IntVar(value=255)
        self.speed_slider = ttk.Scale(speed_frame, from_=0, to=255, 
                                     variable=self.speed_var, orient=tk.HORIZONTAL)
        self.speed_slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.speed_val_label = ttk.Label(speed_frame, text="255", width=4)
        self.speed_val_label.pack(side=tk.LEFT)
        self.speed_btn = ttk.Button(speed_frame, text="Set Speed",
                                   command=self.on_speed_set)
        self.speed_btn.pack(side=tk.LEFT, padx=5)
        
        # Torque settings
        torque_frame = ttk.Frame(quick_set_group)
        torque_frame.pack(fill=tk.X, padx=10, pady=5)
        
        ttk.Label(torque_frame, text="Torque:").pack(side=tk.LEFT)
        self.torque_var = tk.IntVar(value=255)
        self.torque_slider = ttk.Scale(torque_frame, from_=0, to=255, 
                                      variable=self.torque_var, orient=tk.HORIZONTAL)
        self.torque_slider.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)
        self.torque_val_label = ttk.Label(torque_frame, text="255", width=4)
        self.torque_val_label.pack(side=tk.LEFT)
        self.torque_btn = ttk.Button(torque_frame, text="Set Torque",
                                    command=self.on_torque_set)
        self.torque_btn.pack(side=tk.LEFT, padx=5)
        
        # Bind slider value change events
        self.speed_var.trace('w', self.on_speed_changed)
        self.torque_var.trace('w', self.on_torque_changed)
        
        # Tabs
        notebook = ttk.Notebook(frame)
        notebook.pack(fill=tk.BOTH, expand=True)
        
        # System info tab
        sys_info_frame = ttk.Frame(notebook)
        notebook.add(sys_info_frame, text="System Info")
        
        # Connection status - gray background, left-aligned
        conn_group = ttk.LabelFrame(sys_info_frame, text="Connection Status", style='Group.TLabelframe')
        conn_group.pack(fill=tk.X, pady=5)
        
        # Gray background frame
        conn_content_frame = ttk.Frame(conn_group, style='Info.TFrame')
        conn_content_frame.pack(fill=tk.X, padx=10, pady=10)
        
        if self.ros_manager.publisher.get_subscription_count() > 0:
            self.connection_status = ttk.Label(conn_content_frame, text="ROS2 node connected", 
                                              foreground="green", background='#e0e0e0',
                                              anchor='w')
        else:
            self.connection_status = ttk.Label(conn_content_frame, text="ROS2 node not connected", 
                                              foreground="red", background='#e0e0e0',
                                              anchor='w')
        self.connection_status.pack(fill=tk.X)
        
        # Hand info - gray background, left-aligned
        hand_info_group = ttk.LabelFrame(sys_info_frame, text="Hand Info", style='Group.TLabelframe')
        hand_info_group.pack(fill=tk.X, pady=5)
        
        # Gray background frame
        hand_info_content_frame = ttk.Frame(hand_info_group, style='Info.TFrame')
        hand_info_content_frame.pack(fill=tk.X, padx=10, pady=10)
        
        info_text = f"""Hand type: {self.hand_type}
Joint model: {self.hand_joint}
Joint count: {len(self.hand_config.joint_names)}
Publish rate: {self.ros_manager.hz} Hz"""
        self.hand_info_label = ttk.Label(hand_info_content_frame, text=info_text,
                                        background='#e0e0e0', anchor='w', justify='left')
        self.hand_info_label.pack(fill=tk.X)
        
        # Status log tab
        log_frame = ttk.Frame(notebook)
        notebook.add(log_frame, text="Status Log")
        
        # Log text
        self.status_log = scrolledtext.ScrolledText(log_frame, height=15, width=50)
        self.status_log.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.status_log.insert(tk.END, "Waiting for system to start...\n")
        self.status_log.config(state=tk.DISABLED)
        
        # Clear log button
        clear_log_btn = ttk.Button(log_frame, text="Clear Log", 
                                  command=self.clear_status_log)
        clear_log_btn.pack(pady=5)
        
        return frame

    def create_value_display_panel(self):
        """Create slider value display panel"""
        frame = ttk.LabelFrame(self.root, text="Joint Values", style='Group.TLabelframe')
        
        # Buttons row (above display)
        button_frame = ttk.Frame(frame)
        button_frame.pack(fill=tk.X, padx=10, pady=(10, 5))
        
        # Copy button - left aligned
        copy_button = ttk.Button(button_frame, text="Copy to Clipboard", 
                            command=self.copy_values_to_clipboard, width=10)
        copy_button.pack(side=tk.LEFT)
        
        # Values display
        self.value_display = scrolledtext.ScrolledText(frame, height=4, width=100)
        self.value_display.pack(fill=tk.BOTH, expand=True, padx=10, pady=(0, 10))
        self.value_display.insert(tk.END, "[]")
        self.value_display.config(state=tk.DISABLED)
        
        return frame

    def copy_values_to_clipboard(self):
        """Copy joint values to system clipboard"""
        try:
            # Get current button reference
            button = self.root.focus_get()
            original_text = "Copy to Clipboard"
            
            # Get text box content
            content = self.value_display.get(1.0, tk.END).strip()
            
            # Clear selection
            self.value_display.tag_remove(tk.SEL, "1.0", tk.END)
            
            # Copy to clipboard
            self.root.clipboard_clear()
            self.root.clipboard_append(content)
            
            # Change button text to indicate success
            if isinstance(button, ttk.Button):
                button.config(text="Copied!")
                # Restore text after 1.5s
                self.root.after(1500, lambda: button.config(text=original_text))
            
            self.update_status("info", f"Joint values copied to clipboard")
            
        except Exception as e:
            self.update_status("error", f"Copy failed: {str(e)}")

    def on_slider_value_changed(self, index: int, value: str):
        """Slider value changed event handler"""
        value_int = int(float(value))
        if 0 <= index < len(self.slider_labels):
            joint_name = self.hand_config.joint_names[index]
            self.slider_labels[index].config(text=f"{joint_name}: {value_int}")
            
        # Update value display
        self.update_value_display()

    def update_value_display(self):
        """Update value display panel contents"""
        values = [int(float(slider.get())) for slider in self.sliders]
        
        self.value_display.config(state=tk.NORMAL)
        self.value_display.delete(1.0, tk.END)
        self.value_display.insert(tk.END, f"{values}")
        self.value_display.config(state=tk.DISABLED)

    def on_preset_action_clicked(self, positions: List[int], button_index: int = None):
        """Preset action button click handler"""
        if len(positions) != len(self.sliders):
            messagebox.showwarning(
                "Action mismatch", 
                f"Preset action joint count ({len(positions)}) does not match current joint count ({len(self.sliders)})"
            )
            return
        
        # Reset button colors
        self.reset_preset_buttons_color()
        
        # Highlight clicked button
        if button_index is not None and 0 <= button_index < len(self.preset_buttons):
            self.preset_buttons[button_index].config(bg='#1890FF', fg='white')
            self.current_clicked_button = button_index
        
        # Update sliders
        for i, (slider, pos) in enumerate(zip(self.sliders, positions)):
            slider.set(pos)
            self.on_slider_value_changed(i, str(pos))
            
        # Publish joint state
        self.publish_joint_state()

    def on_home_clicked(self):
        """Return to home button click handler"""
        for slider, pos in zip(self.sliders, self.hand_config.init_pos):
            slider.set(pos)
            
        self.publish_joint_state()
        self.update_status("info", "Returned to home position")
        
        # Update value display
        self.update_value_display()

    def on_stop_clicked(self):
        """Stop all actions button click handler"""
        # Stop loop timer
        if self.cycle_timer:
            self.root.after_cancel(self.cycle_timer)
            self.cycle_timer = None
            self.cycle_button.config(text="Cycle Run Preset Actions")
            self.reset_preset_buttons_color()
            
        self.update_status("warning", "Stopped all actions")

    def on_cycle_clicked(self):
        """Cycle run preset actions button click handler"""
        if not self.hand_config.preset_actions:
            messagebox.showwarning("No Preset Actions", "Current hand model has no preset actions to cycle")
            return
            
        if self.cycle_timer:
            # Stop cycling
            self.root.after_cancel(self.cycle_timer)
            self.cycle_timer = None
            self.cycle_button.config(text="Cycle Run Preset Actions")
            self.reset_preset_buttons_color()
            # Restore previously clicked button highlight (if any)
            if hasattr(self, 'current_clicked_button') and self.current_clicked_button is not None:
                if 0 <= self.current_clicked_button < len(self.preset_buttons):
                    self.preset_buttons[self.current_clicked_button].config(bg='#1890FF', fg='white')
            self.update_status("info", "Stopped cycling preset actions")
        else:
            # Start cycling
            self.current_action_index = -1
            self.cycle_button.config(text="Stop Cycling")
            self.update_status("info", "Started cycling preset actions")
            self.run_next_action()

    def run_next_action(self):
        """Run the next preset action"""
        if not self.hand_config.preset_actions:
            return
            
        # Reset button colors
        self.reset_preset_buttons_color()
        
        # Next index
        self.current_action_index = (self.current_action_index + 1) % len(self.hand_config.preset_actions)
        
        # Get next action
        action_names = list(self.hand_config.preset_actions.keys())
        action_name = action_names[self.current_action_index]
        action_positions = self.hand_config.preset_actions[action_name]
        
        # Execute
        self.on_preset_action_clicked(action_positions, self.current_action_index)
        
        # Highlight current (green in cycle mode)
        if 0 <= self.current_action_index < len(self.preset_buttons):
            button = self.preset_buttons[self.current_action_index]
            button.config(bg='#52C41A', fg='white')
        
        self.update_status("info", f"Running preset action: {action_name}")
        
        # Next timer
        self.cycle_timer = self.root.after(LOOP_TIME, self.run_next_action)

    def reset_preset_buttons_color(self):
        """Reset all preset button colors"""
        for button in self.preset_buttons:
            button.config(bg='#E6F7FF', fg='#1890FF')  # Default colors

    def on_speed_changed(self, *args):
        """Speed slider value change event"""
        self.speed_val_label.config(text=str(self.speed_var.get()))

    def on_torque_changed(self, *args):
        """Torque slider value change event"""
        self.torque_val_label.config(text=str(self.torque_var.get()))

    def on_speed_set(self):
        """Set speed"""
        speed_val = self.speed_var.get()
        self.ros_manager.publish_speed(speed_val)
        self.update_status("info", f"Speed set to {speed_val}")

    def on_torque_set(self):
        """Set torque"""
        torque_val = self.torque_var.get()
        self.ros_manager.publish_torque(torque_val)
        self.update_status("info", f"Torque set to {torque_val}")

    def publish_joint_state(self):
        """Publish current joint state"""
        positions = [int(float(slider.get())) for slider in self.sliders]
        self.ros_manager.publish_joint_state(positions)

    def start_publish_timer(self):
        """Start publishing timer"""
        self.publish_joint_state()
        interval = int(1000 / self.ros_manager.hz)
        self.publish_timer_id = self.root.after(interval, self.start_publish_timer)

    def update_status(self, status_type: str, message: str):
        """Update status display"""
        # Update connection status
        if status_type == "info" and "ROS2 node initialized successfully" in message:
            self.connection_status.config(text="ROS2 node connected", foreground="green")
            
        # Update log
        current_time = time.strftime("%H:%M:%S")
        log_entry = f"[{current_time}] {message}\n"
        
        self.status_log.config(state=tk.NORMAL)
        self.status_log.insert(tk.END, log_entry)
        self.status_log.see(tk.END)
        
        # Limit log length
        log_content = self.status_log.get(1.0, tk.END)
        if len(log_content) > 10000:
            self.status_log.delete(1.0, f"{len(log_content)-10000}.0")
            
        self.status_log.config(state=tk.DISABLED)
        
        # Could add color tags for different message types if desired

    def clear_status_log(self):
        """Clear status log"""
        self.status_log.config(state=tk.NORMAL)
        self.status_log.delete(1.0, tk.END)
        self.status_log.insert(tk.END, "Log cleared\n")
        self.status_log.config(state=tk.DISABLED)

    def run(self):
        """Run GUI"""
        try:
            self.root.mainloop()
        finally:
            # Clean timers
            if self.cycle_timer:
                self.root.after_cancel(self.cycle_timer)
            if self.publish_timer_id:
                self.root.after_cancel(self.publish_timer_id)
            # Close ROS2 node
            self.ros_manager.shutdown()

def main(args=None):
    """Main function"""
    try:
        # Create ROS2 node manager
        ros_manager = ROS2NodeManager()
        
        # Create GUI
        gui = HandControlGUI(ros_manager)
        
        # Run app
        gui.run()
            
    except Exception as e:
        print(f"Application failed to start: {str(e)}")
        sys.exit(1)

if __name__ == '__main__':
    main()
